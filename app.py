# -*- coding: utf-8 -*-
"""app.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1gLSEP3wRgJqndJgxrnICljluRL07H7-0
"""
import streamlit as st
import pandas as pd
import datetime
import sys
import os

st.set_page_config(page_title="Sales Forecasting App", layout="centered")
st.title("Sales Forecasting App")

from forecasting import (
    recursive_forecast, arima_forecast, sarimax_forecast, prophet_forecast,
    prophet_data_formatter, plot_model_forecast, model_params,
    download_entity_data, training_data_processor, model_mapes, prophet_mapes
)

# Import Prophet Forecast data
prophet_sales = pd.read_csv("https://raw.githubusercontent.com/varunjoshua/ScalerDSML-ProductSalesForecast/refs/heads/main/data/prophet_forecasts_sales.csv")
prophet_orders = pd.read_csv("https://raw.githubusercontent.com/varunjoshua/ScalerDSML-ProductSalesForecast/refs/heads/main/data/prophet_forecasts_orders.csv")


# Step 1: User Input

entity = st.selectbox("Select Region", ["Company", "Region 1", "Region 2", "Region 3", "Region 4"])
target_choice = st.selectbox("Select Forecast Target", ["Sales", "Orders"])
model_choice = st.selectbox("Select Forecasting Model", ["Linear Regression", "XGBoost", "ARIMA", "SARIMAX", "Prophet"])
m_steps = st.slider("Select Forecast Horizon (in days)", min_value=7, max_value=61, value=30, step=1)


#  Step 2: Load Entity-Specific Data 
ts_data, exog_data = download_entity_data(entity)

#  Step 3: Run Forecast 
if st.button("Run Forecast"):
    test_size = m_steps  

    if model_choice in ["Linear Regression", "XGBoost"]:
        ts_proc = training_data_processor(ts_data.copy(), target_col=target_choice)
        exog_pred = exog_data.head(m_steps)
        model_flag = 'lr' if model_choice == "Linear Regression" else 'xgb'
        forecast = recursive_forecast(ts_proc, exog_pred, model=model_flag, target_col=target_choice)

    elif model_choice == "ARIMA":
        forecast = arima_forecast(
            ts_data.copy(), 
            m_steps, 
            model_params[entity]['arima_order'], 
            target_col=target_choice
            )
        
    elif model_choice == "SARIMAX":
        ts_proc = training_data_processor(ts_data.copy(), target_col=target_choice)
        exog_train = ts_proc[["Holiday", "Discounted Stores"]]
        exog_pred = exog_data[["Holiday", "Discounted Stores"]].head(m_steps)
        forecast = sarimax_forecast(
            ts_proc,
            m_steps,
            exog_train,
            exog_pred,
            model_params[entity]['sarimax_order'],
            model_params[entity]['seasonal_order'],
            target_col=target_choice
            )


    elif model_choice == "Prophet":
        # Select the correct dataframe and column based on user input
        if target_choice == "Sales":
            df = prophet_sales
            col_name = f"{entity}_Sales"
        else:
            df = prophet_orders
            col_name = f"{entity}_Orders"

        # Slice the relevant forecast for the selected horizon
        forecast = df.loc[:m_steps-1, ["Date", col_name]].copy()
        forecast = forecast.rename(columns={col_name: target_choice})
        forecast["Date"] = pd.to_datetime(forecast["Date"])
        forecast = forecast.set_index("Date")
    
    st.markdown("<br>", unsafe_allow_html=True)
    st.markdown("<br>", unsafe_allow_html=True)

    #  Step 4: Plot Forecast 
    st.subheader("Forecast Visualization")
    st.markdown(f"**Model:** {model_choice} | **Target:** {target_choice} | **Entity:** {entity} | **Forecast Horizon:** {m_steps} days")
    fig = plot_model_forecast(
        ts_data.copy(), forecast, model_name=model_choice, inf_label=entity, target_col=target_choice
        )
    st.pyplot(fig)

    #  Step 4.1: Display pre-computed MAPE
    st.markdown("<br>", unsafe_allow_html=True)
    st.subheader("Forecast Report")
    # MAPEs for Prophet
    if model_choice == "Prophet":
        entity_key = entity
        if target_choice == "Sales":
            mape = prophet_mapes.get(entity_key, {}).get('sales_mape')
            if mape is not None:
                st.info(f"Test MAPE: {mape:.2%}")
                st.markdown(
    f"""
    - Sales forecasts generated for Prophet model are pre-computed.
    - The model yielded a best Mean Absolute Percentage Error (MAPE) of {mape:.2%} on the test set when forecasting {entity} {target_choice} over a 61-day horizon.Forecasting with fewer or more steps results in noticeably drop in performance. 
    - The MAPE is a measure of how accurate the forecast is, with lower values indicating better accuracy.
    """
)
                
            else:
                st.info("MAPE not available for this selection.")
        elif target_choice == "Orders":
            mape = prophet_mapes.get(entity_key, {}).get('orders_mape')
            if mape is not None:
                st.info(f"Test MAPE: {mape:.2%}")
                st.markdown(
    f"""
    - Order forecasts generated for Prophet model are pre-computed.
    - The model yielded Mean Absolute Percentage Error (MAPE) of {mape:.2%} on the test set when forecasting {entity} {target_choice} over a 61-day horizon.Forecasting with fewer or more steps results in noticeably drop in performance. 
    - The MAPE is a measure of how accurate the forecast is, with lower values indicating better accuracy.
    """
)
            else:
                st.info("MAPE not available for this selection.")
    else:
        # MAPEs for other models
        key = (entity, target_choice, model_choice)
        if target_choice == "Sales":
            mape_value = model_mapes.get(key)
            if mape_value:
                st.info(f"Test MAPE:  {mape_value}")
                st.markdown(
    f"""
    - The {model_choice} model yielded a Mean Absolute Percentage Error (MAPE) of {mape_value} on the test set when forecasting {entity} {target_choice} over a 61-day horizon.
    - The MAPE is a measure of how accurate the forecast is, with lower values indicating better accuracy.
    - Parameters that resulted in minimum MAPE during test were used for this forecast.
    """
)
            else:
                st.info("MAPE not available for this selection.")
        elif target_choice == "Orders":
            mape_sales_key = (entity, "Sales", model_choice)
            mape_value = model_mapes.get(mape_sales_key)
            if mape_value:
                st.info(f"Orders forecasts for {model_choice} model are untested.")
                st.markdown(
    f"""
    - The {model_choice} model yielded a Mean Absolute Percentage Error (MAPE) of {mape_value} on the test set when forecasting {entity} {target_choice} over a 61-day horizon.</li>
    - The MAPE is a measure of how accurate the forecast is, with lower values indicating better accuracy.</li>
    """,
    unsafe_allow_html=True
)
            else:
                st.info("Orders forecasts are untested. No Sales MAPE is available for this segment/model.")

    # --- Step 5: Show Forecast Table and Download Option ---
    st.markdown("<br>", unsafe_allow_html=True)
    st.subheader("Forecast Table")
    st.dataframe(forecast)

    csv = forecast.to_csv().encode('utf-8')
    st.download_button("Download Forecast as CSV", data=csv, file_name="forecast.csv", mime="text/csv")

    st.success("Forecasting Completed")


